# streamlit_app.py
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# –ó–∞–ø—É—Å–∫:  streamlit run streamlit_app.py
# –¢—Ä–µ–±—É–µ—Ç: streamlit, python-dotenv, openai, geopy, ortools
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
import os
import io
import csv
import re
import logging
from typing import List, Tuple, Optional

import streamlit as st
from dotenv import load_dotenv

import openai
from geopy.distance import geodesic
from ortools.constraint_solver import pywrapcp, routing_enums_pb2

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ¬∑ –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
load_dotenv()
openai.api_key = os.getenv("OPENAI_API_KEY")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 2 ¬∑ –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 3 ¬∑ –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def is_valid_coordinate(lat: float, lon: float) -> bool:
    return -90 <= lat <= 90 and -180 <= lon <= 180


def load_coordinates_from_csv(file) -> List[Tuple[float, float]]:
    """–ß–∏—Ç–∞–µ—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ CSV-—Ñ–∞–π–ª–∞ Streamlit-uploader."""
    coordinates = []
    text_stream = io.TextIOWrapper(file, encoding="utf-8", newline="")
    sample = text_stream.read(1024)
    text_stream.seek(0)
    dialect = csv.Sniffer().sniff(sample)
    reader = csv.DictReader(text_stream, dialect=dialect)

    for row in reader:
        lat_str = row.get("latitude") or row.get("lat") or row.get("Latitude") or row.get("Lat")
        lon_str = row.get("longitude") or row.get("lon") or row.get("Longitude") or row.get("Lon")
        if lat_str is None or lon_str is None:
            st.warning("CSV-—Ñ–∞–π–ª –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –∫–æ–ª–æ–Ω–∫–∏ latitude / longitude.")
            return []
        try:
            lat = float(lat_str)
            lon = float(lon_str)
            if is_valid_coordinate(lat, lon):
                coordinates.append((lat, lon))
            else:
                st.warning(f"–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞: {lat}, {lon}")
        except ValueError:
            st.warning(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã: {lat_str}, {lon_str}")
    return coordinates


def compute_distance_matrix(locations: List[Tuple[float, float]]) -> List[List[int]]:
    size = len(locations)
    matrix = []
    for i in range(size):
        row = []
        for j in range(size):
            if i == j:
                row.append(0)
            else:
                row.append(int(geodesic(locations[i], locations[j]).meters))
        row  # noqa: B018
        matrix.append(row)
    return matrix


def optimize_route_with_ortools(coordinates: List[Tuple[float, float]]) -> Optional[List[Tuple[float, float]]]:
    try:
        data = {"locations": coordinates, "num_vehicles": 1, "depot": 0}
        manager = pywrapcp.RoutingIndexManager(len(data["locations"]), data["num_vehicles"], data["depot"])
        routing = pywrapcp.RoutingModel(manager)
        distance_matrix = compute_distance_matrix(data["locations"])

        def distance_callback(from_index, to_index):
            return distance_matrix[manager.IndexToNode(from_index)][manager.IndexToNode(to_index)]

        routing.RegisterTransitCallback(distance_callback)
        routing.SetArcCostEvaluatorOfAllVehicles(0)

        search_parameters = pywrapcp.DefaultRoutingSearchParameters()
        search_parameters.first_solution_strategy = routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC
        search_parameters.local_search_metaheuristic = routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH
        search_parameters.time_limit.seconds = 30

        solution = routing.SolveWithParameters(search_parameters)
        if not solution:
            return None

        route = []
        index = routing.Start(0)
        while not routing.IsEnd(index):
            node_index = manager.IndexToNode(index)
            route.append(data["locations"][node_index])
            index = solution.Value(routing.NextVar(index))
        route.append(data["locations"][manager.IndexToNode(index)])
        return route
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ OR-Tools: {e}", exc_info=True)
        return None


def optimize_route_with_openai(coordinates: List[Tuple[float, float]]) -> Optional[List[Tuple[float, float]]]:
    coord_str = "\n".join(f"{i+1}. {lat},{lon}" for i, (lat, lon) in enumerate(coordinates))
    prompt = (
        "–û–ø—Ç–∏–º–∏–∑–∏—Ä—É–π –ø–æ—Ä—è–¥–æ–∫ —Å–ª–µ–¥—É—é—â–∏—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –¥–ª—è –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏–∏ –æ–±—â–µ–≥–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –º–∞—Ä—à—Ä—É—Ç–∞. "
        "–í–µ—Ä–Ω–∏ —Ç–æ–ª—å–∫–æ —Å–ø–∏—Å–æ–∫ –Ω–æ–º–µ—Ä–æ–≤ –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞, —Ä–∞–∑–¥–µ–ª—ë–Ω–Ω—ã—Ö –∑–∞–ø—è—Ç—ã–º–∏, –±–µ–∑ –ª–∏—à–Ω–µ–≥–æ —Ç–µ–∫—Å—Ç–∞.\n\n"
        f"{coord_str}"
    )
    try:
        rsp = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "–¢—ã –ø–æ–º–æ—â–Ω–∏–∫ –ø–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –º–∞—Ä—à—Ä—É—Ç–æ–≤."},
                {"role": "user", "content": prompt},
            ],
            temperature=0,
            max_tokens=150,
        )
        order_str = rsp.choices[0].message.content.strip()
        if not re.match(r"^(\d+\s*,\s*)*\d+\s*$", order_str):
            return None
        idxs = [int(n) - 1 for n in re.findall(r"\d+", order_str)]
        if len(set(idxs)) != len(coordinates) or any(i >= len(coordinates) for i in idxs):
            return None
        return [coordinates[i] for i in idxs]
    except openai.error.RateLimitError:
        st.warning("–î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç OpenAI, –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ OR-Tools.")
        return None
    except Exception as e:
        logger.error(f"OpenAI error: {e}", exc_info=True)
        return None


def optimize_route(coordinates: List[Tuple[float, float]]) -> Tuple[Optional[List[Tuple[float, float]]], str]:
    if not coordinates:
        return None, ""
    if len(coordinates) <= 10:
        res = optimize_route_with_openai(coordinates)
        if res:
            return res, "OpenAI GPT-3.5-turbo"
    res = optimize_route_with_ortools(coordinates)
    return res, "OR-Tools" if res else ""


def create_google_maps_links(coordinates: List[Tuple[float, float]]) -> List[str]:
    MAX = 24
    links = []
    for i in range(0, len(coordinates), MAX):
        chunk = coordinates[i : i + MAX]
        route = "/".join(f"{lat},{lon}" for lat, lon in chunk)
        links.append(f"https://www.google.com/maps/dir/{route}")
    return links

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 4 ¬∑ UI Streamlit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
st.set_page_config(page_title="–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –º–∞—Ä—à—Ä—É—Ç–∞", layout="wide")
st.title("üöö –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –º–∞—Ä—à—Ä—É—Ç–∞ –¥–æ—Å—Ç–∞–≤–æ–∫")

with st.expander("–ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ–º?"):
    st.markdown(
        """
1. –í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–± –≤–≤–æ–¥–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç:  
   ‚Ä¢ **–í—Ä—É—á–Ω—É—é** ‚Äî –≤–≤–µ–¥–∏—Ç–µ —à–∏—Ä–æ—Ç—É –∏ –¥–æ–ª–≥–æ—Ç—É –¥–ª—è –∫–∞–∂–¥–æ–π —Ç–æ—á–∫–∏.  
   ‚Ä¢ **CSV-—Ñ–∞–π–ª** ‚Äî –∑–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–∞–π–ª —Å –∫–æ–ª–æ–Ω–∫–∞–º–∏ `latitude` –∏ `longitude`.  
   ‚Ä¢ **Bulk** ‚Äî –≤—Å—Ç–∞–≤—å—Ç–µ —Å–ø–∏—Å–æ–∫ —Ç–æ—á–µ–∫ (`lat,lon`) –ø–æ—Å—Ç—Ä–æ—á–Ω–æ.  
2. –ù–∞–∂–º–∏—Ç–µ **¬´–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –º–∞—Ä—à—Ä—É—Ç¬ª**.  
3. –ü–æ–ª—É—á–∏—Ç–µ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ —Ç–æ—á–µ–∫ –∏ –≥–æ—Ç–æ–≤—ã–µ —Å—Å—ã–ª–∫–∏ –¥–ª—è Google Maps.  
"""
    )

method = st.radio(
    "–°–ø–æ—Å–æ–± –≤–≤–æ–¥–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç",
    ["–í—Ä—É—á–Ω—É—é", "CSV-—Ñ–∞–π–ª", "Bulk-–≤–≤–æ–¥"],
    horizontal=True,
)

coordinates: List[Tuple[float, float]] = []

# ¬´–í—Ä—É—á–Ω—É—é¬ª
if method == "–í—Ä—É—á–Ω—É—é":
    cols_qty = st.number_input("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫", min_value=1, max_value=25, value=3, step=1)
    st.markdown("–í–≤–µ–¥–∏—Ç–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã:")
    lat_inputs, lon_inputs = [], []
    for i in range(int(cols_qty)):
        c1, c2 = st.columns(2)
        lat = c1.text_input(f"–®–∏—Ä–æ—Ç–∞ {i+1}", key=f"lat_{i}")
        lon = c2.text_input(f"–î–æ–ª–≥–æ—Ç–∞ {i+1}", key=f"lon_{i}")
        lat_inputs.append(lat)
        lon_inputs.append(lon)
    if st.button("–î–æ–±–∞–≤–∏—Ç—å –µ—â—ë —Å—Ç—Ä–æ–∫—É"):
        st.session_state["lat_" + str(cols_qty)] = ""
        st.session_state["lon_" + str(cols_qty)] = ""
        st.experimental_rerun()

    for lat_str, lon_str in zip(lat_inputs, lon_inputs):
        if lat_str and lon_str:
            try:
                lat, lon = float(lat_str), float(lon_str)
                if is_valid_coordinate(lat, lon):
                    coordinates.append((lat, lon))
                else:
                    st.error(f"–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞: {lat}, {lon}")
            except ValueError:
                st.error(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç: {lat_str}, {lon_str}")

# ¬´CSV-—Ñ–∞–π–ª¬ª
elif method == "CSV-—Ñ–∞–π–ª":
    uploaded_file = st.file_uploader("–ó–∞–≥—Ä—É–∑–∏—Ç–µ CSV", type=["csv"])
    if uploaded_file:
        coordinates = load_coordinates_from_csv(uploaded_file)

# ¬´Bulk¬ª
else:  # Bulk-–≤–≤–æ–¥
    bulk_text = st.text_area("–í—Å—Ç–∞–≤—å—Ç–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã (–∫–∞–∂–¥–∞—è —Å—Ç—Ä–æ–∫–∞: lat,lon)")
    if bulk_text.strip():
        for line in bulk_text.strip().splitlines():
            parts = line.split(",")
            if len(parts) != 2:
                st.warning(f"–ü—Ä–æ–ø—É—Å–∫–∞—é —Å—Ç—Ä–æ–∫—É (–Ω–µ 2 —ç–ª–µ–º–µ–Ω—Ç–∞): {line}")
                continue
            try:
                lat, lon = float(parts[0].strip()), float(parts[1].strip())
                if is_valid_coordinate(lat, lon):
                    coordinates.append((lat, lon))
                else:
                    st.warning(f"–í–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞: {lat}, {lon}")
            except ValueError:
                st.warning(f"–ù–µ–≤–µ—Ä–Ω–æ–µ —á–∏—Å–ª–æ –≤ —Å—Ç—Ä–æ–∫–µ: {line}")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 5 ¬∑ –ó–∞–ø—É—Å–∫ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if st.button("üöÄ –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –º–∞—Ä—à—Ä—É—Ç"):
    if not coordinates:
        st.error("–ù–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç.")
        st.stop()

    with st.spinner("–°—á–∏—Ç–∞–µ–º –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç‚Ä¶"):
        optimized, tech = optimize_route(coordinates)

    if not optimized:
        st.error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –º–∞—Ä—à—Ä—É—Ç.")
        st.stop()

    # –í—ã–≤–æ–¥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    st.success(f"–ú–∞—Ä—à—Ä—É—Ç –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω ({tech}).")
    st.subheader("–ü–æ—Ä—è–¥–æ–∫ —Ç–æ—á–µ–∫:")
    for i, (lat, lon) in enumerate(optimized, 1):
        st.write(f"{i}. {lat}, {lon}")

    st.subheader("–°—Å—ã–ª–∫–∏ –¥–ª—è Google Maps:")
    for idx, link in enumerate(create_google_maps_links(optimized), 1):
        st.markdown(f"[–ú–∞—Ä—à—Ä—É—Ç #{idx}]({link})")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
